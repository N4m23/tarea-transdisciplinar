<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tela Interactiva con Audio</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: #fff;
            font-family: Arial, sans-serif;
        }

        .container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        #debug {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 5px;
            font-size: 12px;
            color: #fff;
            z-index: 1000;
            display: none;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.core.min.js"></script>
</head>
<body>
<div class="container">
    <canvas id="canvas"></canvas>
    <div id="debug"></div>
</div>

<script>
    // Configuración del canvas
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const debug = document.getElementById('debug');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // Mostrar información de debug si es necesario (para desarrollo)
    const showDebug = false;
    if (showDebug) {
        debug.style.display = 'block';
    }

    // Ajuste del canvas cuando cambia el tamaño de la ventana
    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    });

    // Configuración de audio con manejo de errores
    const audioFiles = ['agitacion.mp3', 'incertidumbre.mp3', 'atencion.mp3', 'presencia.mp3', 'suspension.mp3', 'desconexion.mp3'];
    const audios = {};
    let audioLoadCount = 0;
    let audioErrorCount = 0;

    // Cargar los archivos de audio con manejo de errores
    audioFiles.forEach(file => {
        const name = file.split('.')[0];
        audios[name] = new Howl({
            src: [file],
            loop: true,
            volume: 0,
            onload: function() {
                audioLoadCount++;
                logDebug(`Audio cargado: ${file}`);
                if (name === 'desconexion' && audioLoadCount === 1) {
                    // Comenzar con desconexion tan pronto como esté disponible
                    startAudioTransition('desconexion');
                }
            },
            onloaderror: function(id, err) {
                audioErrorCount++;
                logDebug(`Error al cargar ${file}: ${err}`);
                
                // Si hay error al cargar, crear un reemplazo silencioso
                audios[name] = createSilentAudio();
            }
        });
    });

    // Crea un reemplazo silencioso para audios que no se pueden cargar
    function createSilentAudio() {
        return {
            play: function() { return this; },
            stop: function() { return this; },
            fade: function(from, to, duration) { return this; },
            volume: function(vol) { if (vol !== undefined) return this; return 0; },
            playing: function() { return false; }
        };
    }

    // Función para mostrar información de debug
    function logDebug(message) {
        if (showDebug) {
            console.log(message);
            debug.innerHTML += message + '<br>';
            // Limitar el número de líneas
            if (debug.innerHTML.split('<br>').length > 20) {
                debug.innerHTML = debug.innerHTML.split('<br>').slice(-20).join('<br>');
            }
        }
    }

    // Secuencia definida de reproducción
    const audioSequence = ['agitacion', 'incertidumbre', 'atencion', 'presencia', 'suspension', 'desconexion'];
    let currentAudioIndex = 5; // Empezamos con desconexion (índice 5)
    let currentAudio = null;
    let isFirstInteraction = true;
    let hasInteracted = false;
    
    // Estado actual del sistema
    let systemState = {
        audioPlaying: false,
        currentAudioName: 'none',
        mouseInCanvas: false,
        mouseSpeed: 0
    };

    // Variables para el control del mouse
    let lastPos = { x: 0, y: 0 };
    let lastTime = Date.now();
    let mouseStillTime = Date.now();
    let mouseSpeed = 0;
    let mouseInCanvas = false;

    // Variables para el suavizado de la transición de audio
    const transitionDuration = 2000; // Duración de la transición en milisegundos
    const audioVolume = {
        agitacion: 0.7,         // Más volumen para asegurar que se escuche
        incertidumbre: 0.6,
        atencion: 0.5,
        presencia: 0.4,
        suspension: 0.3,
        desconexion: 0.2        // Algo de volumen para asegurar que sea audible
    };

    // Constantes para la simulación
    const stillnessThreshold = 3000; // Tiempo de inactividad para cambiar el audio (ms)
    const baseWindForce = 0.002;    // Mayor fuerza base para asegurar el movimiento
    const volumeFactor = 25;       // Mayor sensibilidad al volumen para el movimiento de la tela

    // Función para reproducir el siguiente audio en la secuencia
    function playNextInSequence(direction = 1) {
        currentAudioIndex = (currentAudioIndex + direction + audioSequence.length) % audioSequence.length;
        const audioName = audioSequence[currentAudioIndex];
        startAudioTransition(audioName);
    }

    // Función para seleccionar el audio basado en la interacción
    function selectAudioBasedOnInteraction() {
        if (!mouseInCanvas || Date.now() - mouseStillTime > 8000) {
            // Si el mouse no está en el canvas o está inmóvil por mucho tiempo
            return 'desconexion';
        }
        
        if (mouseSpeed > 0.35) {
            return 'agitacion';
        } else if (mouseSpeed > 0.15) {
            return 'incertidumbre';
        } else if (mouseSpeed > 0.05) {
            return 'atencion';
        } else if (mouseSpeed > 0.01) {
            return 'presencia';
        } else if (Date.now() - mouseStillTime > stillnessThreshold) {
            return 'suspension';
        } else {
            return audioSequence[currentAudioIndex]; // Mantener el audio actual
        }
    }

    // Función para activar la transición de audio
    function startAudioTransition(audioName) {
        logDebug(`Transición a audio: "${audioName}"`);
        
        if (!audios[audioName]) {
            logDebug(`Error: No se encontró el audio "${audioName}"`);
            return;
        }
        
        // Guardar estado
        systemState.currentAudioName = audioName;
        
        if (currentAudio && currentAudio.playing) {
            try {
                currentAudio.fade(currentAudio.volume(), 0, transitionDuration);
                
                // Programar la detención después de fundirse a cero
                setTimeout(() => {
                    if (currentAudio && currentAudio.stop) {
                        currentAudio.stop();
                    }
                }, transitionDuration);
            } catch (e) {
                logDebug(`Error al detener audio anterior: ${e.message}`);
            }
        }
        
        try {
            const targetAudio = audios[audioName];
            targetAudio.volume(0);
            targetAudio.play();
            targetAudio.fade(0, audioVolume[audioName], transitionDuration);
            
            currentAudio = targetAudio;
            currentAudioIndex = audioSequence.indexOf(audioName);
            systemState.audioPlaying = true;
        } catch (e) {
            logDebug(`Error al iniciar nuevo audio: ${e.message}`);
            systemState.audioPlaying = false;
        }
    }

    // Detectar movimiento del mouse con manejo de errores
    canvas.addEventListener('mousemove', (e) => {
        try {
            if (!hasInteracted) {
                hasInteracted = true;
                startAudioTransition('desconexion');
            }
            
            const now = Date.now();
            const dx = e.clientX - lastPos.x;
            const dy = e.clientY - lastPos.y;
            const timeDelta = now - lastTime;
            
            // Calcular velocidad con suavizado
            if (timeDelta > 0) {
                const instantSpeed = Math.sqrt(dx * dx + dy * dy) / timeDelta;
                mouseSpeed = mouseSpeed * 0.9 + instantSpeed * 0.1; // Suavizado
                systemState.mouseSpeed = mouseSpeed;
            }
            
            // Actualizar posición y tiempo
            lastPos = { x: e.clientX, y: e.clientY };
            lastTime = now;
            
            // Resetear contador de inactividad
            if (mouseSpeed > 0.005) {
                mouseStillTime = now;
            }
            
            // Seleccionar audio basado en la interacción
            const audioName = selectAudioBasedOnInteraction();
            if (audioName && audioSequence[currentAudioIndex] !== audioName) {
                startAudioTransition(audioName);
            }
        } catch (e) {
            logDebug(`Error en evento mousemove: ${e.message}`);
        }
    });

    // Detectar cuando el mouse entra y sale del canvas
    canvas.addEventListener('mouseenter', () => {
        mouseInCanvas = true;
        systemState.mouseInCanvas = true;
        if (!hasInteracted) {
            hasInteracted = true;
            startAudioTransition('desconexion');
        }
    });

    canvas.addEventListener('mouseleave', () => {
        mouseInCanvas = false;
        systemState.mouseInCanvas = false;
        startAudioTransition('desconexion');
    });

    // Iniciar con el audio de desconexión al cargar el documento
    document.addEventListener('DOMContentLoaded', () => {
        setTimeout(() => {
            logDebug("DOM cargado, iniciando audio de desconexión");
            startAudioTransition('desconexion');
        }, 500);
    });

    // Verificar el estado de carga de los audios
    setInterval(() => {
        if (audioLoadCount === audioFiles.length) {
            logDebug("Todos los audios cargados correctamente");
        } else if (audioErrorCount > 0) {
            logDebug(`Cargados ${audioLoadCount}/${audioFiles.length}, con ${audioErrorCount} errores`);
        }
    }, 5000);

    // Simulación de tela
    const clothWidth = 400;
    const clothHeight = 300;
    const numPointsX = 30;
    const numPointsY = 20;
    const restDistance = clothWidth / numPointsX;

    class Point {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.originalX = x;
            this.originalY = y;
            this.vx = 0;
            this.vy = 0;
            this.pinned = false;
            this.mass = 1;
        }
    }

    class Cloth {
        constructor() {
            this.points = [];

            for (let y = 0; y <= numPointsY; y++) {
                for (let x = 0; x <= numPointsX; x++) {
                    const u = x / numPointsX;
                    const v = y / numPointsY;

                    const px = canvas.width / 2 - clothWidth / 2 + clothWidth * u;
                    const py = canvas.height / 2 - clothHeight / 2 + clothHeight * v;

                    const point = new Point(px, py);

                    if (y === 0) {
                        point.pinned = true;
                    }

                    this.points.push(point);
                }
            }

            this.getPoint = (x, y) => this.points[y * (numPointsX + 1) + x];

            this.constraints = [];

            for (let y = 0; y <= numPointsY; y++) {
                for (let x = 0; x <= numPointsX; x++) {
                    if (x < numPointsX) {
                        this.constraints.push({
                            p1: this.getPoint(x, y),
                            p2: this.getPoint(x + 1, y),
                            distance: restDistance
                        });
                    }
                    if (y < numPointsY) {
                        this.constraints.push({
                            p1: this.getPoint(x, y),
                            p2: this.getPoint(x, y + 1),
                            distance: restDistance
                        });
                    }
                    if (x < numPointsX && y < numPointsY) {
                        this.constraints.push({
                            p1: this.getPoint(x, y),
                            p2: this.getPoint(x + 1, y + 1),
                            distance: Math.sqrt(restDistance * restDistance * 2)
                        });
                        this.constraints.push({
                            p1: this.getPoint(x + 1, y),
                            p2: this.getPoint(x, y + 1),
                            distance: Math.sqrt(restDistance * restDistance * 2)
                        });
                    }
                }
            }
        }

        update(dt) {
            try {
                // Constantes físicas
                const GRAVITY = 0.01 * dt;
                const DAMPING = 0.98;
                const DRAG = 1 - 0.02;

                // Aplicar fuerzas
                for (let i = 0; i < this.points.length; i++) {
                    const point = this.points[i];
                    if (!point.pinned) {
                        // Acumular fuerzas
                        point.vy += GRAVITY;

                        // Aplicar una leve atracción hacia el centro para mantener la tela visible
                        const centerX = canvas.width / 2;
                        const centerY = canvas.height / 2;
                        const toCenterX = (centerX - point.x) * 0.0001;
                        const toCenterY = (centerY - point.y) * 0.0001;
                        point.vx += toCenterX;
                        point.vy += toCenterY;

                        // Amortiguación y arrastre
                        point.vx *= DRAG;
                        point.vy *= DRAG;

                        // Integración de Verlet
                        const prevX = point.x;
                        const prevY = point.y;

                        point.x += point.vx;
                        point.y += point.vy;

                        // Actualizar velocidades con amortiguación
                        point.vx = (point.x - prevX) * DAMPING;
                        point.vy = (point.y - prevY) * DAMPING;
                    }
                }

                // Resolver restricciones para mantener la estructura de la tela
                const iterations = 15;
                for (let i = 0; i < iterations; i++) {
                    for (let j = 0; j < this.constraints.length; j++) {
                        const constraint = this.constraints[j];
                        const p1 = constraint.p1;
                        const p2 = constraint.p2;

                        // Cálculo de la distancia actual
                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        const currentDistance = Math.sqrt(dx * dx + dy * dy);

                        if (currentDistance > 0) {
                            // Calcular dirección y corrección
                            const diff = (constraint.distance - currentDistance) / currentDistance;

                            // Distribuir corrección según si los puntos están fijados o no
                            const percent1 = p1.pinned ? 0 : 0.5;
                            const percent2 = p2.pinned ? 0 : 0.5;

                            const offsetX = dx * diff;
                            const offsetY = dy * diff;

                            // Aplicar corrección
                            p1.x -= offsetX * percent1;
                            p1.y -= offsetY * percent1;

                            p2.x += offsetX * percent2;
                            p2.y += offsetY * percent2;
                        }
                    }
                }
            } catch (e) {
                logDebug(`Error en update de cloth: ${e.message}`);
            }
        }

        // Aplicar fuerza de viento (movimiento constante + respuesta al audio)
        applyWindForce(forceX, forceY) {
            try {
                // Añadir oscilación natural para simular "respiración"
                const time = Date.now() * 0.001;
                const breathingForce = Math.sin(time * 0.5) * 0.005; // Aumentado para asegurar movimiento visible
                
                for (let i = 0; i < this.points.length; i++) {
                    const point = this.points[i];
                    if (!point.pinned) {
                        // Añadir turbulencia aleatoria suave pero más notoria
                        let randomX = (Math.random() - 0.5) * 0.04;
                        let randomY = (Math.random() - 0.5) * 0.02;
                        
                        // Alternar dirección para crear movimiento más natural
                        if (i % 4 === 0) {
                            randomX *= -1;
                        }
                        
                        // Combinar fuerzas: base + respiración + audio + aleatoria
                        point.vx += forceX + breathingForce + randomX;
                        point.vy += forceY + randomY;
                    }
                }
            } catch (e) {
                logDebug(`Error en applyWindForce: ${e.message}`);
            }
        }

        draw() {
            try {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = "#000";
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Dibujar cada celda de la tela
                for (let y = 0; y < numPointsY; y++) {
                    for (let x = 0; x < numPointsX; x++) {
                        const p1 = this.getPoint(x, y);
                        const p2 = this.getPoint(x + 1, y);
                        const p3 = this.getPoint(x + 1, y + 1);
                        const p4 = this.getPoint(x, y + 1);

                        // Calcular el centro para el gradiente
                        const centerX = (p1.x + p2.x + p3.x + p4.x) / 4;
                        const centerY = (p1.y + p2.y + p3.y + p4.y) / 4;

                        // Calcular normal para iluminación
                        const nx = (p3.y - p1.y);
                        const ny = -(p3.x - p1.x);
                        const norm = Math.sqrt(nx * nx + ny * ny);
                        
                        if (norm > 0) {
                            const normalX = nx / norm;
                            const normalY = ny / norm;

                            // Iluminación simple
                            const lightX = 0.5;
                            const lightY = -1;
                            const lightIntensity = (normalX * lightX + normalY * lightY) * 0.5 + 0.5;

                            // Ajustar brillo manteniendo tonos blancos
                            const brightness = Math.floor(220 + lightIntensity * 35);

                            // Dibujar la celda
                            ctx.beginPath();
                            ctx.moveTo(p1.x, p1.y);
                            ctx.lineTo(p2.x, p2.y);
                            ctx.lineTo(p3.x, p3.y);
                            ctx.lineTo(p4.x, p4.y);
                            ctx.closePath();

                            // Crear gradiente para dar profundidad
                            const gradient = ctx.createRadialGradient(
                                centerX, centerY, 0,
                                centerX, centerY, restDistance * 1.5
                            );

                            // Color uniforme blanco con variación sutil de brillo
                            gradient.addColorStop(0, `rgba(${brightness}, ${brightness}, ${brightness}, 0.95)`);
                            gradient.addColorStop(1, `rgba(${brightness-15}, ${brightness-15}, ${brightness-15}, 0.9)`);

                            ctx.fillStyle = gradient;
                            ctx.fill();

                            // Líneas sutiles para definir la estructura
                            ctx.strokeStyle = `rgba(255, 255, 255, 0.05)`;
                            ctx.lineWidth = 0.4;
                            ctx.stroke();
                        }
                    }
                }
            } catch (e) {
                logDebug(`Error en draw: ${e.message}`);
            }
        }
    }

    // Crear tela
    const cloth = new Cloth();

    // Bucle de animación
    function animate() {
        try {
            const now = Date.now();
            const dt = Math.min((now - (animate.lastTime || now)) / 16.66, 2); // Limitar dt para estabilidad
            animate.lastTime = now;

            // Determinar la fuerza del viento:
            
            // 1. Fuerza base siempre presente (para la "respiración")
            let windForceX = baseWindForce;
            
            // 2. Si hay audio, aumentar basado en el volumen
            if (currentAudio && typeof currentAudio.volume === 'function') {
                const volume = currentAudio.volume();
                if (typeof volume === 'number') {
                    windForceX += volume * volumeFactor;
                }
            } 
            
            // 3. Agregar fuerza adicional basada en mouse para asegurar movimiento
            if (mouseSpeed > 0.01) {
                windForceX += mouseSpeed * 0.1;
            }
            
            // Asegurar un valor mínimo para tener movimiento
            windForceX = Math.max(windForceX, 0.003);

            // Actualizar estado de debug
            if (showDebug && now % 1000 < 50) {
                logDebug(`Audio: ${systemState.currentAudioName}, Force: ${windForceX.toFixed(4)}`);
            }

            // Aplicar fuerzas, actualizar física y dibujar
            cloth.applyWindForce(windForceX, 0);
            cloth.update(dt);
            cloth.draw();

            // Continuar animación
            requestAnimationFrame(animate);
        } catch (e) {
            logDebug(`Error en animate: ${e.message}`);
            requestAnimationFrame(animate); // Continuar incluso si hay error
        }
    }

    // Intentar reproducir audio al primer clic/toque (necesario en algunos navegadores)
    document.addEventListener('click', function initialClick() {
        logDebug("Primer clic detectado, iniciando audio");
        startAudioTransition('desconexion');
        hasInteracted = true;
        document.removeEventListener('click', initialClick);
    });

    // Iniciar la simulación
    logDebug("Iniciando simulación");
    animate();
</script>
</body>
</html>
