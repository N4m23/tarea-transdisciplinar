<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tela Interactiva con Audio</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: #fff;
            font-family: Arial, sans-serif;
        }

        .container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
</head>
<body>
<div class="container">
    <canvas id="canvas"></canvas>
</div>

<script>
    // Configuración del canvas
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Ajustar el canvas si cambia el tamaño de la ventana
    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    });

    // Definición de los estados de audio en orden secuencial
    const audioSequence = [
        'agitacion', 
        'incertidumbre', 
        'atencion', 
        'presencia', 
        'suspension', 
        'desconexion'
    ];

    // Configuración de los archivos de audio con Howler.js
    const audios = {
        suspension: new Howl({ src: ['suspension.mp3'], loop: true, volume: 0 }),
        presencia: new Howl({ src: ['presencia.mp3'], loop: true, volume: 0 }),
        atencion: new Howl({ src: ['atencion.mp3'], loop: true, volume: 0 }),
        incertidumbre: new Howl({ src: ['incertidumbre.mp3'], loop: true, volume: 0 }),
        agitacion: new Howl({ src: ['agitacion.mp3'], loop: true, volume: 0 }),
        desconexion: new Howl({ src: ['desconexion.mp3'], loop: true, volume: 0 })
    };

    // Volúmenes para cada estado de audio
    const audioVolume = {
        suspension: 0.6,
        presencia: 0.5,
        atencion: 0.4,
        incertidumbre: 0.3,
        agitacion: 0.7,
        desconexion: 0.2
    };

    // Variables de control
    let currentAudioState = 'desconexion'; // Iniciar con desconexion
    let currentAudio = audios[currentAudioState];
    let lastPos = { x: 0, y: 0 };
    let lastInteractionTime = Date.now();
    let hasInteracted = false;
    let currentAudioIndex = 5; // Índice para desconexion

    // Duración de la transición entre audios
    const transitionDuration = 2000; // ms

    // Tiempo de inactividad para volver a desconexion
    const inactivityThreshold = 3000; // ms

    // Función para cambiar de estado de audio
    function changeAudioState(newState) {
        if (currentAudioState === newState) return;

        console.log(`Cambiando de ${currentAudioState} a ${newState}`);
        
        // Bajar volumen del audio actual
        if (currentAudio) {
            currentAudio.fade(currentAudio.volume(), 0, transitionDuration);
            setTimeout(() => {
                if (currentAudio !== audios[newState]) {
                    currentAudio.pause();
                }
            }, transitionDuration);
        }

        // Actualizar estado y audio actual
        currentAudioState = newState;
        currentAudio = audios[newState];
        
        // Encontrar índice del nuevo estado en la secuencia
        currentAudioIndex = audioSequence.indexOf(newState);
        
        // Iniciar reproducción y subir volumen
        if (!currentAudio.playing()) {
            currentAudio.play();
        }
        currentAudio.fade(0, audioVolume[newState], transitionDuration);
    }

    // Función para procesar el movimiento del ratón
    function handleMouseMovement(e) {
        const now = Date.now();
        
        // Marcar como interactuado
        if (!hasInteracted) {
            hasInteracted = true;
            changeAudioState('agitacion'); // Comienza con agitación al interactuar
        }
        
        // Actualizar tiempo de última interacción
        lastInteractionTime = now;
        
        // Calcular velocidad del movimiento
        const dx = e.clientX - lastPos.x;
        const dy = e.clientY - lastPos.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Actualizar posición
        lastPos = { x: e.clientX, y: e.clientY };
        
        // Determinar estado de audio basado en la velocidad
        if (distance > 40) {
            changeAudioState('agitacion');
        } else if (distance > 20) {
            changeAudioState('incertidumbre');
        } else if (distance > 5) {
            changeAudioState('atencion');
        } else if (distance > 0) {
            changeAudioState('presencia');
        } else {
            // Si no hay movimiento pero hay interacción reciente, ir a suspensión
            const timeSinceLastMovement = now - lastInteractionTime;
            if (timeSinceLastMovement < 1000) {
                changeAudioState('suspension');
            }
        }
    }

    // Detección de inactividad para pasar a desconexión
    function checkInactivity() {
        const now = Date.now();
        const timeSinceLastInteraction = now - lastInteractionTime;
        
        if (hasInteracted && timeSinceLastInteraction > inactivityThreshold) {
            changeAudioState('desconexion');
        }
    }

    // Evento para detectar si el cursor sale del canvas
    canvas.addEventListener('mouseleave', () => {
        changeAudioState('desconexion');
    });

    // Evento para detectar movimiento del cursor
    canvas.addEventListener('mousemove', handleMouseMovement);

    // Evento para detectar cuando el cursor está en el canvas pero quieto
    canvas.addEventListener('mouseenter', (e) => {
        lastPos = { x: e.clientX, y: e.clientY };
        lastInteractionTime = Date.now();
    });

    // Evento para click, que simula una interacción más intensa
    canvas.addEventListener('click', () => {
        if (currentAudioState !== 'agitacion') {
            changeAudioState('agitacion');
        }
    });

    // Simulación de tela
    const clothWidth = 400;
    const clothHeight = 300;
    const numPointsX = 30;
    const numPointsY = 20;
    const restDistance = clothWidth / numPointsX;

    class Point {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.originalX = x;
            this.originalY = y;
            this.vx = 0;
            this.vy = 0;
            this.pinned = false;
            this.mass = 1;
        }
    }

    class Cloth {
        constructor() {
            this.points = [];

            for (let y = 0; y <= numPointsY; y++) {
                for (let x = 0; x <= numPointsX; x++) {
                    const u = x / numPointsX;
                    const v = y / numPointsY;

                    const px = canvas.width / 2 - clothWidth / 2 + clothWidth * u;
                    const py = canvas.height / 2 - clothHeight / 2 + clothHeight * v;

                    const point = new Point(px, py);

                    if (y === 0) {
                        point.pinned = true;
                    }

                    this.points.push(point);
                }
            }

            this.getPoint = (x, y) => this.points[y * (numPointsX + 1) + x];

            this.constraints = [];

            for (let y = 0; y <= numPointsY; y++) {
                for (let x = 0; x <= numPointsX; x++) {
                    if (x < numPointsX) {
                        this.constraints.push({
                            p1: this.getPoint(x, y),
                            p2: this.getPoint(x + 1, y),
                            distance: restDistance
                        });
                    }
                    if (y < numPointsY) {
                        this.constraints.push({
                            p1: this.getPoint(x, y),
                            p2: this.getPoint(x, y + 1),
                            distance: restDistance
                        });
                    }
                    if (x < numPointsX && y < numPointsY) {
                        this.constraints.push({
                            p1: this.getPoint(x, y),
                            p2: this.getPoint(x + 1, y + 1),
                            distance: Math.sqrt(restDistance * restDistance * 2)
                        });
                        this.constraints.push({
                            p1: this.getPoint(x + 1, y),
                            p2: this.getPoint(x, y + 1),
                            distance: Math.sqrt(restDistance * restDistance * 2)
                        });
                    }
                }
            }
        }

        update(dt) {
            // Constantes físicas
            const GRAVITY = 0.0981 * dt;
            const DAMPING = 0.98;
            const DRAG = 1 - 0.01;

            // Aplicar fuerzas
            for (let i = 0; i < this.points.length; i++) {
                const point = this.points[i];
                if (!point.pinned) {
                    // Acumular fuerzas
                    point.vy += GRAVITY;

                    // Aplicar un pequeño desplazamiento hacia el centro
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    const toCenterX = (centerX - point.x) * 0.0001;
                    const toCenterY = (centerY - point.y) * 0.0001;
                    point.vx += toCenterX;
                    point.vy += toCenterY;

                    // Amortiguación y arrastre
                    point.vx *= DRAG;
                    point.vy *= DRAG;

                    // Integración de Verlet
                    const prevX = point.x;
                    const prevY = point.y;

                    point.x += point.vx;
                    point.y += point.vy;

                    // Actualizar velocidades con amortiguación
                    point.vx = (point.x - prevX) * DAMPING;
                    point.vy = (point.y - prevY) * DAMPING;
                }
            }

            // Resolver restricciones
            const iterations = 15;
            for (let i = 0; i < iterations; i++) {
                for (let j = 0; j < this.constraints.length; j++) {
                    const constraint = this.constraints[j];
                    const p1 = constraint.p1;
                    const p2 = constraint.p2;

                    // Cálculo de la distancia actual
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const currentDistance = Math.sqrt(dx * dx + dy * dy);

                    if (currentDistance > 0) {
                        // Calcular dirección...
                        const diff = (constraint.distance - currentDistance) / currentDistance;

                        // Distribuir corrección
                        const percent1 = p1.pinned ? 0 : 0.5;
                        const percent2 = p2.pinned ? 0 : 0.5;

                        const offsetX = dx * diff;
                        const offsetY = dy * diff;

                        p1.x -= offsetX * percent1;
                        p1.y -= offsetY * percent1;

                        p2.x += offsetX * percent2;
                        p2.y += offsetY * percent2;
                    }
                }
            }
        }

        // Aplicar fuerza de viento con base en el volumen de audio
        applyWindForce(dt) {
            // Base de movimiento continuo (respiración)
            const time = Date.now() / 1000;
            const baseWindX = Math.sin(time) * 0.001;
            const baseWindY = Math.cos(time * 0.7) * 0.0005;
            
            // Amplificación basada en volumen de audio
            let audioAmplification = 1;
            
            if (currentAudio) {
                // Factor de amplificación basado en el estado de audio actual
                const stateFactor = {
                    'agitacion': 3.0,
                    'incertidumbre': 2.0,
                    'atencion': 1.5,
                    'presencia': 1.0,
                    'suspension': 0.5,
                    'desconexion': 0.2
                };
                
                audioAmplification = currentAudio.volume() * stateFactor[currentAudioState];
            }
            
            for (let i = 0; i < this.points.length; i++) {
                const point = this.points[i];
                if (!point.pinned) {
                    // Efecto de respiración base
                    const breathingFactor = Math.sin(time + i * 0.1) * 0.0005;
                    
                    // Turbulencia aleatoria, más intensa con audio más fuerte
                    const turbulence = (Math.random() - 0.5) * 0.01 * audioAmplification;
                    
                    // Crear un patrón de ondas para el movimiento
                    const waveX = Math.sin(time + point.originalY * 0.01) * 0.003 * audioAmplification;
                    const waveY = Math.cos(time + point.originalX * 0.01) * 0.003 * audioAmplification;
                    
                    // Aplicar fuerzas
                    point.vx += baseWindX + waveX + turbulence + breathingFactor;
                    point.vy += baseWindY + waveY + turbulence + breathingFactor;
                }
            }
        }

        draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let y = 0; y < numPointsY; y++) {
                for (let x = 0; x < numPointsX; x++) {
                    const p1 = this.getPoint(x, y);
                    const p2 = this.getPoint(x + 1, y);
                    const p3 = this.getPoint(x + 1, y + 1);
                    const p4 = this.getPoint(x, y + 1);

                    const centerX = (p1.x + p2.x + p3.x + p4.x) / 4;
                    const centerY = (p1.y + p2.y + p3.y + p4.y) / 4;

                    const nx = (p3.y - p1.y);
                    const ny = -(p3.x - p1.x);
                    const norm = Math.sqrt(nx * nx + ny * ny);

                    const normalX = nx / norm;
                    const normalY = ny / norm;

                    const lightX = 0.5;
                    const lightY = -1;
                    const lightIntensity = (normalX * lightX + normalY * lightY) * 0.5 + 0.5;

                    // Brillo basado en audio
                    let brightness = 225;
                    if (currentAudio) {
                        // Añadir un poco de variación basada en el volumen
                        brightness = 200 + (currentAudio.volume() * 55);
                    }
                    
                    const finalBrightness = Math.floor(brightness * (lightIntensity * 0.3 + 0.7));

                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.lineTo(p3.x, p3.y);
                    ctx.lineTo(p4.x, p4.y);
                    ctx.closePath();

                    const gradient = ctx.createRadialGradient(
                        centerX, centerY, 0,
                        centerX, centerY, restDistance * 2
                    );

                    gradient.addColorStop(0, `rgba(${finalBrightness}, ${finalBrightness}, ${finalBrightness}, 0.9)`);
                    gradient.addColorStop(1, `rgba(${finalBrightness-20}, ${finalBrightness-20}, ${finalBrightness-20}, 0.85)`);

                    ctx.fillStyle = gradient;
                    ctx.fill();

                    ctx.strokeStyle = `rgba(255, 255, 255, 0.06)`;
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                }
            }
        }
    }

    // Crear tela
    const cloth = new Cloth();

    // Iniciar la simulación
    function animate() {
        const now = Date.now();
        const dt = (now - (animate.lastTime || now)) / 16.66;
        animate.lastTime = now;

        // Verificar inactividad
        checkInactivity();

        // Aplicar fuerzas y actualizar la simulación
        cloth.applyWindForce(dt);
        cloth.update(dt);
        cloth.draw();

        requestAnimationFrame(animate);
    }

    // Iniciar audio de desconexión y animación
    function init() {
        changeAudioState('desconexion');
        animate();
    }

    // Iniciar cuando todo esté cargado
    window.addEventListener('load', init);
</script>
</body>
</html>
