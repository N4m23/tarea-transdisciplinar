<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Compresión y Expansión</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: #fff;
            font-family: Arial, sans-serif;
            cursor: pointer;
            touch-action: none;
        }

        canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            touch-action: none;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>

    <script>
        // Configuración del canvas
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Desactivar el menú contextual en dispositivos táctiles
        canvas.addEventListener('contextmenu', function(e) {
            e.preventDefault();
        });
        //touch
        canvas.style.touchAction = 'none';

        // Configuración de archivos de audio
        const audioFiles = [
            'agitacion.mp3',
            'incertidumbre.mp3',
            'atencion.mp3',
            'presencia.mp3',
            'suspension.mp3',
            'desconexion.mp3'
        ];

        let currentAudio = null;

        // Para automatizar la reproducción
        let inactivityTimeout;
        const inactivityTime = 10000; // Valor por defecto
        let autoSequence = ['incertidumbre.mp3', 'atencion.mp3', 'presencia.mp3', 'suspension.mp3', 'desconexion.mp3'];
        let autoSequenceIndex = 0;

        //Eventos
        canvas.addEventListener('mousemove', handlePointerMove);
        canvas.addEventListener('touchmove', handlePointerMove);
        canvas.addEventListener('click', handleCanvasClick);
        canvas.addEventListener('touchstart', handleTouchStart);

        //Objetos audio
        let audios = [];

        //Estado
        let isPlaying = false;
        let lastInteractionTime = 0;
        let audioContext;

        //Puntero
        let pointerX = canvas.width / 2;
        let pointerY = canvas.height / 2;
        let pointerSpeedX = 0;
        let pointerSpeedY = 0;
        let totalMovement = 0;

        //Simulación de tela
        const clothWidth = 400;
        const clothHeight = 300;
        const numPointsX = 30;
        const numPointsY = 20;
        const restDistance = clothWidth / numPointsX;

        class Point {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.originalX = x;
                this.originalY = y;
                this.vx = 0;
                this.vy = 0;
                this.pinned = false;
                this.mass = 1;
            }
        }

        class Cloth {
            constructor() {
                this.points = [];
                for (let y = 0; y <= numPointsY; y++) {
                    for (let x = 0; x < numPointsX; x++) {
                        const u = x / numPointsX;
                        const v = y / numPointsY;
                        const px = canvas.width / 2 - clothWidth / 2 + clothWidth * u;
                        const py = canvas.height / 2 - clothHeight / 2 + clothHeight * v;
                        const point = new Point(px, py);
                        point.pinned = y === 0;
                        this.points.push(point);
                    }
                }

                this.constraints = [];
                for (let y = 0; y <= numPointsY; y++) {
                    for (let x = 0; x < numPointsX; x++) {
                        this.constraints.push({
                            p1: this.getPoint(x, y),
                            p2: this.getPoint(x + 1, y),
                            distance: restDistance
                        });
                    }
                }
                for (let x = 0; x <= numPointsX; x++) {
                    for (let y = 0; y < numPointsY; y++) {
                        this.constraints.push({
                            p1: this.getPoint(x, y),
                            p2: this.getPoint(x, y + 1),
                            distance: restDistance
                        });
                    }
                }
                this.getPoint = (x, y) => this.points[y * (numPointsX + 1) + x];
            }

            update(dt) {
                const GRAVITY = 0.0981 * dt;
                const DAMPING = 0.97;

                for (let i = 0; i < this.points.length; i++) {
                    const point = this.points[i];
                    if (!point.pinned) {
                        point.vy += GRAVITY;
                        const prevX = point.x;
                        const prevY = point.y;
                        point.x += point.vx;
                        point.y += point.vy;
                        point.vx = (point.x - prevX) * DAMPING;
                        point.vy = (point.y - prevY) * DAMPING;
                    }
                }
                const iterations = 15;
                for (let i = 0; i < iterations; i++) {
                    for (let j = 0; j < this.constraints.length; j++) {
                        const constraint = this.constraints[j];
                        const p1 = constraint.p1;
                        const p2 = constraint.p2;

                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const diff = (constraint.distance - distance) / distance;
                        const percent = p1.pinned ? 0 : 0.5;

                        p1.x -= dx * diff * percent;
                        p1.y -= dy * diff * percent;
                        p2.x += dx * diff * (1 - percent);
                        p2.y += dy * diff * (1 - percent);
                    }
                }
            }

            draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = "#000";
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.strokeStyle = "rgba(255, 255, 255, 0.7)";
                ctx.lineWidth = 2;

                for (let y = 0; y < numPointsY; y++) {
                    for (let x = 0; x < numPointsX; x++) {
                        const p1 = this.getPoint(x, y);
                        const p2 = this.getPoint(x + 1, y);
                        const p3 = this.getPoint(x + 1, y + 1);
                        const p4 = this.getPoint(x, y + 1);

                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.lineTo(p3.x, p3.y);
                        ctx.lineTo(p4.x, p4.y);
                        ctx.closePath();
                        ctx.stroke();
                    }
                }
            }
        }

        const cloth = new Cloth();

        // Touch
        function handleTouchStart() {
            if (!audioContext) {
                initAudioContext();
            }
        }
        // Inicializa el audio
        function initAudioContext() {
            audioContext = new(window.AudioContext || window.webkitAudioContext)();
            audios = audioFiles.map(file => {
                const audio = new Audio(file);
                audio.volume = 0.7;
                return audio
            });

            playAudio("incertidumbre.mp3");
        }
        //Inactividad
        function startInactivityTimer() {
            inactivityTimeout = setTimeout(() => {
                playAudio('incertidumbre.mp3');
            }, inactivityTime);
        }
        // Resetear el tiempo
        function resetInactivityTimer() {
            clearTimeout(inactivityTimeout);
            startInactivityTimer();
        }
        // Interacciones click
        function handleCanvasClick(e) {
            playAudio('atencion.mp3');
            resetInactivityTimer();
        }
        // Tocar los audios
        function playAudio(audioName) {
            resetInactivityTimer();
            if (!audioContext) {
                initAudioContext();
            }
            //Buscar audios
            let audioToPlay = audios.find(audio => audio.src.includes(audioName));
            if (!audioToPlay) {
                return;
            }
            //Evitar loops
            if (currentAudio && currentAudio !== audioToPlay) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
            }
            currentAudio = audioToPlay;
            audioToPlay.play();
        }
        // Touch
        function handlePointerMove(event) {
            event.preventDefault();

            let clientX, clientY;
            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            //Mover la tela
            pointerSpeedX = clientX - pointerX;
            pointerSpeedY = clientY - pointerY;

            const distance = Math.sqrt(pointerSpeedX * pointerSpeedX + pointerSpeedY * pointerSpeedY);
            totalMovement += distance;
            const movementSpeed = Math.sqrt(pointerSpeedX * pointerSpeedX + pointerSpeedY * pointerSpeedY)
            pointerX = clientX;
            pointerY = clientY;
            lastInteractionTime = performance.now();

            //Ajuste de audio
            if (movementSpeed > 5) {
                playAudio('agitacion.mp3');
            } else if (movementSpeed > 2) {
                playAudio('presencia.mp3');
            } else {
                playAudio('suspension.mp3');
            }

            // Fuerza a la tela
            const pointerForceRadius = 150;
            const pointerForce = 0.5;

            for (let i = 0; i < cloth.points.length; i++) {
                const point = cloth.points[i];
                const dx = point.x - pointerX;
                const dy = point.y - pointerY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < pointerForceRadius) {
                    const force = (1 - dist / pointerForceRadius) * pointerForce;
                    point.vx += (pointerSpeedX * force) / point.mass;
                    point.vy += (pointerSpeedY * force) / point.mass;
                }
            }
        }
        // Iniciar automatización
        startInactivityTimer();

        //Redimensionar
        window.addEventListener('resize', function() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        //Animación
        let lastTime = performance.now();

        function animate() {
            const currentTime = performance.now();
            const deltaTime = (currentTime - lastTime) / 16;
            lastTime = currentTime;
            cloth.update(deltaTime);
            cloth.draw(); //Llamar a la función para renderizar
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>

</html>





