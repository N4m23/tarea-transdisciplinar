<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tela Interactiva con Audio</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: #fff;
            font-family: Arial, sans-serif;
        }

        .container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
</head>
<body>
<div class="container">
    <canvas id="canvas"></canvas>
</div>

<script>
    // Configuración del canvas
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Configuración de audio (Howler.js)
    const audios = {
        suspension: new Howl({ src: ['suspension.mp3'], loop: true, volume: 0 }),
        presencia: new Howl({ src: ['presencia.mp3'], loop: true, volume: 0 }),
        atencion: new Howl({ src: ['atencion.mp3'], loop: true, volume: 0 }),
        incertidumbre: new Howl({ src: ['incertidumbre.mp3'], loop: true, volume: 0 }),
        agitacion: new Howl({ src: ['agitacion.mp3'], loop: true, volume: 0 }),
        panico: new Howl({ src: ['panico.mp3'], loop: true, volume: 0 }),
        desconexion: new Howl({ src: ['desconexion.mp3'], loop: true, volume: 0 })
    };

    let currentAudio = null;
    let lastPos = { x: 0, y: 0 };
    let lastTime = Date.now();
    let mouseStillTime = null;

    // Variables para el suavizado de la transición de audio
    let targetAudio = null;
    const transitionDuration = 2000; // Duración de la transición en milisegundos
    const baseWindForce = 0.001; // Fuerza base del viento
    const volumeFactor = 50;
    const stillnessThreshold = 2000;
    const audioVolume = {
        suspension: 0.05,
        presencia: 0.2,
        atencion: 0.3,
        incertidumbre: 0.4,
        agitacion: 0.6,
        panico: 0.8,
        desconexion: 0
    };

    // Función para seleccionar el audio basado en la descripción
    function selectAudio(speed) {
        if (mouseStillTime !== null && Date.now() - mouseStillTime > stillnessThreshold) {
            return 'desconexion';
        }

        if (speed < 0.05) {
            return 'suspension';
        } else if (speed < 0.1) {
            return 'presencia';
        } else if (speed < 0.2) {
            return 'atencion';
        } else if (speed < 0.4) {
            return 'incertidumbre';
        } else if (speed < 0.7) {
            return 'agitacion';
        } else {
            return 'panico';
        }
    }

    // Función para activar la transición de audio
    function startAudioTransition(audioName) {
        if (currentAudio !== audios[audioName]) {
            targetAudio = audios[audioName];
            if (currentAudio) {
                currentAudio.fade(currentAudio.volume(), 0, transitionDuration);
            }
            targetAudio.volume(0);
            targetAudio.fade(0, audioVolume[audioName], transitionDuration);
            targetAudio.play();
            currentAudio = targetAudio;
        }
    }

    // Detección de movimiento del mouse
    document.addEventListener('mousemove', (e) => {
        const now = Date.now();
        const dx = e.clientX - lastPos.x;
        const dy = e.clientY - lastPos.y;
        const speed = Math.sqrt(dx * dx + dy * dy) / (now - lastTime);

        lastPos = { x: e.clientX, y: e.clientY };
        lastTime = now;

        if (speed > 0.01) {
            mouseStillTime = null;
        } else if (mouseStillTime === null) {
            mouseStillTime = now;
        }

        const audioName = selectAudio(speed);
        startAudioTransition(audioName);
    });

    // Simulación de tela
    const clothWidth = 400;
    const clothHeight = 300;
    const numPointsX = 30;
    const numPointsY = 20;
    const restDistance = clothWidth / numPointsX;

    class Point {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.originalX = x;
            this.originalY = y;
            this.vx = 0;
            this.vy = 0;
            this.pinned = false;
            this.mass = 1;
        }
    }

    class Cloth {
        constructor() {
            this.points = [];

            for (let y = 0; y <= numPointsY; y++) {
                for (let x = 0; x <= numPointsX; x++) {
                    const u = x / numPointsX;
                    const v = y / numPointsY;

                    const px = canvas.width / 2 - clothWidth / 2 + clothWidth * u;
                    const py = canvas.height / 2 - clothHeight / 2 + clothHeight * v;

                    const point = new Point(px, py);

                    if (y === 0) {
                        point.pinned = true;
                    }

                    this.points.push(point);
                }
            }

            this.getPoint = (x, y) => this.points[y * (numPointsX + 1) + x];

            this.constraints = [];

            for (let y = 0; y <= numPointsY; y++) {
                for (let x = 0; x < numPointsX; x++) {
                    if (x < numPointsX) {
                        this.constraints.push({
                            p1: this.getPoint(x, y),
                            p2: this.getPoint(x + 1, y),
                            distance: restDistance
                        });
                    }
                    if (y < numPointsY) {
                        this.constraints.push({
                            p1: this.getPoint(x, y),
                            p2: this.getPoint(x, y + 1),
                            distance: restDistance
                        });
                    }
                    if (x < numPointsX && y < numPointsY) {
                        this.constraints.push({
                            p1: this.getPoint(x, y),
                            p2: this.getPoint(x + 1, y + 1),
                            distance: Math.sqrt(restDistance * restDistance * 2)
                        });
                        this.constraints.push({
                            p1: this.getPoint(x + 1, y),
                            p2: this.getPoint(x, y + 1),
                            distance: Math.sqrt(restDistance * restDistance * 2)
                        });
                    }
                }
            }
        }

        update(dt) {
            const GRAVITY = 0.0981 * dt;
            const DAMPING = 0.97;
            const DRAG = 1 - 0.02;

            for (let i = 0; i < this.points.length; i++) {
                const point = this.points[i];
                if (!point.pinned) {
                    point.vy += GRAVITY;

                    point.vx *= DRAG;
                    point.vy *= DRAG;

                    const prevX = point.x;
                    const prevY = point.y;

                    point.x += point.vx;
                    point.y += point.vy;

                    point.vx = (point.x - prevX) * DAMPING;
                    point.vy = (point.y - prevY) * DAMPING;
                }
            }

            const iterations = 15;
            for (let i = 0; i < iterations; i++) {
                for (let j = 0; j < this.constraints.length; j++) {
                    const constraint = this.constraints[j];
                    const p1 = constraint.p1;
                    const p2 = constraint.p2;

                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const currentDistance = Math.sqrt(dx * dx + dy * dy);

                    if (currentDistance > 0) {
                        const diff = (constraint.distance - currentDistance) / currentDistance;

                        const percent1 = p1.pinned ? 0 : 0.5;
                        const percent2 = p2.pinned ? 0 : 0.5;

                        const offsetX = dx * diff;
                        const offsetY = dy * diff;

                        p1.x -= offsetX * percent1;
                        p1.y -= offsetY * percent1;

                        p2.x += offsetX * percent2;
                        p2.y += offsetY * percent2;
                    }
                }
            }
        }

        applyWindForce(forceX, forceY) {
            for (let i = 0; i < this.points.length; i++) {
                const point = this.points[i];
                if (!point.pinned) {
                    const randomX = (Math.random() - 0.5) * 0.1;
                    const randomY = (Math.random() - 0.5) * 0.1;

                    point.vx += forceX + randomX;
                    point.vy += forceY + randomY;
                }
            }
        }

        draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let y = 0; y < numPointsY; y++) {
                for (let x = 0; x < numPointsX; x++) {
                    const p1 = this.getPoint(x, y);
                    const p2 = this.getPoint(x + 1, y);
                    const p3 = this.getPoint(x + 1, y + 1);
                    const p4 = this.getPoint(x, y + 1);

                    const centerX = (p1.x + p2.x + p3.x + p4.x) / 4;
                    const centerY = (p1.y + p2.y + p3.y + p4.y) / 4;

                    const nx = (p3.y - p1.y);
                    const ny = -(p3.x - p1.x);
                    const norm = Math.sqrt(nx * nx + ny * ny);

                    const normalX = nx / norm;
                    const normalY = ny / norm;

                    const lightX = 0.5;
                    const lightY = -1;
                    const lightIntensity = (normalX * lightX + normalY * lightY) * 0.5 + 0.5;

                    const brightness = Math.floor(210 + lightIntensity * 45);

                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.lineTo(p3.x, p3.y);
                    ctx.lineTo(p4.x, p4.y);
                    ctx.closePath();

                    const gradient = ctx.createRadialGradient(
                        centerX, centerY, 0,
                        centerX, centerY, restDistance * 2
                    );

                    gradient.addColorStop(0, `rgba(${brightness}, ${brightness}, ${brightness}, 0.9)`);
                    gradient.addColorStop(1, `rgba(${brightness-20}, ${brightness-20}, ${brightness-20}, 0.85)`);

                    ctx.fillStyle = gradient;
                    ctx.fill();

                    ctx.strokeStyle = `rgba(255, 255, 255, 0.06)`;
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                }
            }
        }
    }

    // Crear tela
    const cloth = new Cloth();

    // Bucle de animación
    function animate() {
        const now = Date.now();
        const dt = (now - (animate.lastTime || now)) / 16.66;
        animate.lastTime = now;

        let windForceX = baseWindForce;

        if (currentAudio) {
            windForceX = baseWindForce + (currentAudio.volume() * volumeFactor);
        }

        cloth.applyWindForce(windForceX, 0);
        cloth.update(dt);
        cloth.draw();

        requestAnimationFrame(animate);
    }

    // Iniciar la simulación con el audio de "suspension"
    startAudioTransition('suspension');
    animate();
</script>
</body>
</html>
