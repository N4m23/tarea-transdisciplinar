<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tela Interactiva con Audio</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: #fff;
            font-family: Arial, sans-serif;
        }

        .container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
</head>
<body>
<div class="container">
    <canvas id="canvas"></canvas>
</div>

<script>
    // Configuración del canvas
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Ajuste del canvas cuando cambia el tamaño de la ventana
    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    });

    // Configuración de audio (Howler.js)
    const audios = {
        agitacion: new Howl({ src: ['agitacion.mp3'], loop: true, volume: 0 }),
        incertidumbre: new Howl({ src: ['incertidumbre.mp3'], loop: true, volume: 0 }),
        atencion: new Howl({ src: ['atencion.mp3'], loop: true, volume: 0 }),
        presencia: new Howl({ src: ['presencia.mp3'], loop: true, volume: 0 }),
        suspension: new Howl({ src: ['suspension.mp3'], loop: true, volume: 0 }),
        desconexion: new Howl({ src: ['desconexion.mp3'], loop: true, volume: 0 })
    };

    // Secuencia definida de reproducción
    const audioSequence = ['agitacion', 'incertidumbre', 'atencion', 'presencia', 'suspension', 'desconexion'];
    let currentAudioIndex = 5; // Empezamos con desconexion (índice 5)
    let currentAudio = null;
    let isFirstInteraction = true;
    let hasInteracted = false;

    // Variables para el control del mouse
    let lastPos = { x: 0, y: 0 };
    let lastTime = Date.now();
    let mouseStillTime = Date.now();
    let mouseSpeed = 0;
    let mouseInCanvas = false;

    // Variables para el suavizado de la transición de audio
    const transitionDuration = 2500; // Duración de la transición en milisegundos
    const audioVolume = {
        agitacion: 0.45,
        incertidumbre: 0.32,
        atencion: 0.22,
        presencia: 0.12,
        suspension: 0.03,
        desconexion: 0.1 // Un poco de volumen para que sea audible
    };

    // Constantes para la simulación
    const stillnessThreshold = 3000; // Tiempo de inactividad para cambiar el audio (ms)
    const baseWindForce = 0.001; // Fuerza base del viento (suave respiración)
    const volumeFactor = 20; // Sensibilidad al volumen para el movimiento de la tela

    // Función para reproducir el siguiente audio en la secuencia
    function playNextInSequence(direction = 1) {
        currentAudioIndex = (currentAudioIndex + direction + audioSequence.length) % audioSequence.length;
        const audioName = audioSequence[currentAudioIndex];
        startAudioTransition(audioName);
    }

    // Función para seleccionar el audio basado en la interacción
    function selectAudioBasedOnInteraction() {
        if (!mouseInCanvas || Date.now() - mouseStillTime > 8000) {
            // Si el mouse no está en el canvas o está inmóvil por mucho tiempo
            return 'desconexion';
        }
        
        if (mouseSpeed > 0.35) {
            return 'agitacion';
        } else if (mouseSpeed > 0.15) {
            return 'incertidumbre';
        } else if (mouseSpeed > 0.05) {
            return 'atencion';
        } else if (mouseSpeed > 0.01) {
            return 'presencia';
        } else if (Date.now() - mouseStillTime > stillnessThreshold) {
            return 'suspension';
        } else {
            return audioSequence[currentAudioIndex]; // Mantener el audio actual
        }
    }

    // Función para activar la transición de audio
    function startAudioTransition(audioName) {
        if (currentAudio && currentAudio.playing()) {
            currentAudio.fade(currentAudio.volume(), 0, transitionDuration);
            
            // Programar la detención después de fundirse a cero
            setTimeout(() => {
                if (currentAudio) {
                    currentAudio.stop();
                }
            }, transitionDuration);
        }
        
        const targetAudio = audios[audioName];
        targetAudio.volume(0);
        targetAudio.play();
        targetAudio.fade(0, audioVolume[audioName], transitionDuration);
        
        currentAudio = targetAudio;
        currentAudioIndex = audioSequence.indexOf(audioName);
    }

    // Detectar movimiento del mouse
    canvas.addEventListener('mousemove', (e) => {
        if (!hasInteracted) {
            hasInteracted = true;
            startAudioTransition('desconexion');
        }
        
        const now = Date.now();
        const dx = e.clientX - lastPos.x;
        const dy = e.clientY - lastPos.y;
        const timeDelta = now - lastTime;
        
        // Calcular velocidad con suavizado
        if (timeDelta > 0) {
            const instantSpeed = Math.sqrt(dx * dx + dy * dy) / timeDelta;
            mouseSpeed = mouseSpeed * 0.9 + instantSpeed * 0.1; // Suavizado
        }
        
        // Actualizar posición y tiempo
        lastPos = { x: e.clientX, y: e.clientY };
        lastTime = now;
        
        // Resetear contador de inactividad
        if (mouseSpeed > 0.005) {
            mouseStillTime = now;
        }
        
        // Seleccionar audio basado en la interacción
        const audioName = selectAudioBasedOnInteraction();
        if (audioName && audioSequence[currentAudioIndex] !== audioName) {
            startAudioTransition(audioName);
        }
    });

    // Detectar cuando el mouse entra y sale del canvas
    canvas.addEventListener('mouseenter', () => {
        mouseInCanvas = true;
        if (!hasInteracted) {
            hasInteracted = true;
            startAudioTransition('desconexion');
        }
    });

    canvas.addEventListener('mouseleave', () => {
        mouseInCanvas = false;
        startAudioTransition('desconexion');
    });

    // Iniciar con el audio de desconexión
    document.addEventListener('DOMContentLoaded', () => {
        setTimeout(() => {
            startAudioTransition('desconexion');
        }, 500);
    });

    // Simulación de tela
    const clothWidth = 400;
    const clothHeight = 300;
    const numPointsX = 30;
    const numPointsY = 20;
    const restDistance = clothWidth / numPointsX;

    class Point {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.originalX = x;
            this.originalY = y;
            this.vx = 0;
            this.vy = 0;
            this.pinned = false;
            this.mass = 1;
        }
    }

    class Cloth {
        constructor() {
            this.points = [];

            for (let y = 0; y <= numPointsY; y++) {
                for (let x = 0; x <= numPointsX; x++) {
                    const u = x / numPointsX;
                    const v = y / numPointsY;

                    const px = canvas.width / 2 - clothWidth / 2 + clothWidth * u;
                    const py = canvas.height / 2 - clothHeight / 2 + clothHeight * v;

                    const point = new Point(px, py);

                    if (y === 0) {
                        point.pinned = true;
                    }

                    this.points.push(point);
                }
            }

            this.getPoint = (x, y) => this.points[y * (numPointsX + 1) + x];

            this.constraints = [];

            for (let y = 0; y <= numPointsY; y++) {
                for (let x = 0; x <= numPointsX; x++) {
                    if (x < numPointsX) {
                        this.constraints.push({
                            p1: this.getPoint(x, y),
                            p2: this.getPoint(x + 1, y),
                            distance: restDistance
                        });
                    }
                    if (y < numPointsY) {
                        this.constraints.push({
                            p1: this.getPoint(x, y),
                            p2: this.getPoint(x, y + 1),
                            distance: restDistance
                        });
                    }
                    if (x < numPointsX && y < numPointsY) {
                        this.constraints.push({
                            p1: this.getPoint(x, y),
                            p2: this.getPoint(x + 1, y + 1),
                            distance: Math.sqrt(restDistance * restDistance * 2)
                        });
                        this.constraints.push({
                            p1: this.getPoint(x + 1, y),
                            p2: this.getPoint(x, y + 1),
                            distance: Math.sqrt(restDistance * restDistance * 2)
                        });
                    }
                }
            }
        }

        update(dt) {
            // Constantes físicas
            const GRAVITY = 0.01 * dt;
            const DAMPING = 0.98;
            const DRAG = 1 - 0.02;

            // Aplicar fuerzas
            for (let i = 0; i < this.points.length; i++) {
                const point = this.points[i];
                if (!point.pinned) {
                    // Acumular fuerzas
                    point.vy += GRAVITY;

                    // Aplicar una leve atracción hacia el centro para mantener la tela visible
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    const toCenterX = (centerX - point.x) * 0.0001;
                    const toCenterY = (centerY - point.y) * 0.0001;
                    point.vx += toCenterX;
                    point.vy += toCenterY;

                    // Amortiguación y arrastre
                    point.vx *= DRAG;
                    point.vy *= DRAG;

                    // Integración de Verlet
                    const prevX = point.x;
                    const prevY = point.y;

                    point.x += point.vx;
                    point.y += point.vy;

                    // Actualizar velocidades con amortiguación
                    point.vx = (point.x - prevX) * DAMPING;
                    point.vy = (point.y - prevY) * DAMPING;
                }
            }

            // Resolver restricciones para mantener la estructura de la tela
            const iterations = 15;
            for (let i = 0; i < iterations; i++) {
                for (let j = 0; j < this.constraints.length; j++) {
                    const constraint = this.constraints[j];
                    const p1 = constraint.p1;
                    const p2 = constraint.p2;

                    // Cálculo de la distancia actual
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const currentDistance = Math.sqrt(dx * dx + dy * dy);

                    if (currentDistance > 0) {
                        // Calcular dirección y corrección
                        const diff = (constraint.distance - currentDistance) / currentDistance;

                        // Distribuir corrección según si los puntos están fijados o no
                        const percent1 = p1.pinned ? 0 : 0.5;
                        const percent2 = p2.pinned ? 0 : 0.5;

                        const offsetX = dx * diff;
                        const offsetY = dy * diff;

                        // Aplicar corrección
                        p1.x -= offsetX * percent1;
                        p1.y -= offsetY * percent1;

                        p2.x += offsetX * percent2;
                        p2.y += offsetY * percent2;
                    }
                }
            }
        }

        // Aplicar fuerza de viento (movimiento constante + respuesta al audio)
        applyWindForce(forceX, forceY) {
            // Añadir oscilación natural para simular "respiración"
            const time = Date.now() * 0.001;
            const breathingForce = Math.sin(time * 0.5) * 0.002;
            
            for (let i = 0; i < this.points.length; i++) {
                const point = this.points[i];
                if (!point.pinned) {
                    // Añadir turbulencia aleatoria suave
                    let randomX = (Math.random() - 0.5) * 0.02;
                    let randomY = (Math.random() - 0.5) * 0.01;
                    
                    // Alternar dirección para crear movimiento más natural
                    if (i % 4 === 0) {
                        randomX *= -1;
                    }
                    
                    // Combinar fuerzas: base + respiración + audio + aleatoria
                    point.vx += forceX + breathingForce + randomX;
                    point.vy += forceY + randomY;
                }
            }
        }

        draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Dibujar cada celda de la tela
            for (let y = 0; y < numPointsY; y++) {
                for (let x = 0; x < numPointsX; x++) {
                    const p1 = this.getPoint(x, y);
                    const p2 = this.getPoint(x + 1, y);
                    const p3 = this.getPoint(x + 1, y + 1);
                    const p4 = this.getPoint(x, y + 1);

                    // Calcular el centro para el gradiente
                    const centerX = (p1.x + p2.x + p3.x + p4.x) / 4;
                    const centerY = (p1.y + p2.y + p3.y + p4.y) / 4;

                    // Calcular normal para iluminación
                    const nx = (p3.y - p1.y);
                    const ny = -(p3.x - p1.x);
                    const norm = Math.sqrt(nx * nx + ny * ny);
                    
                    if (norm > 0) {
                        const normalX = nx / norm;
                        const normalY = ny / norm;

                        // Iluminación simple
                        const lightX = 0.5;
                        const lightY = -1;
                        const lightIntensity = (normalX * lightX + normalY * lightY) * 0.5 + 0.5;

                        // Ajustar brillo manteniendo tonos blancos
                        const brightness = Math.floor(220 + lightIntensity * 35);

                        // Dibujar la celda
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.lineTo(p3.x, p3.y);
                        ctx.lineTo(p4.x, p4.y);
                        ctx.closePath();

                        // Crear gradiente para dar profundidad
                        const gradient = ctx.createRadialGradient(
                            centerX, centerY, 0,
                            centerX, centerY, restDistance * 1.5
                        );

                        // Color uniforme blanco con variación sutil de brillo
                        gradient.addColorStop(0, `rgba(${brightness}, ${brightness}, ${brightness}, 0.95)`);
                        gradient.addColorStop(1, `rgba(${brightness-15}, ${brightness-15}, ${brightness-15}, 0.9)`);

                        ctx.fillStyle = gradient;
                        ctx.fill();

                        // Líneas sutiles para definir la estructura
                        ctx.strokeStyle = `rgba(255, 255, 255, 0.05)`;
                        ctx.lineWidth = 0.4;
                        ctx.stroke();
                    }
                }
            }
        }
    }

    // Crear tela
    const cloth = new Cloth();

    // Bucle de animación
    function animate() {
        const now = Date.now();
        const dt = Math.min((now - (animate.lastTime || now)) / 16.66, 2); // Limitar dt para estabilidad
        animate.lastTime = now;

        // Fuerza base del viento (siempre presente para la "respiración")
        let windForceX = baseWindForce;
        
        // Aumentar fuerza basada en el volumen del audio actual
        if (currentAudio && currentAudio.playing()) {
            windForceX += currentAudio.volume() * volumeFactor;
        }

        // Aplicar fuerzas, actualizar física y dibujar
        cloth.applyWindForce(windForceX, 0);
        cloth.update(dt);
        cloth.draw();

        // Continuar animación
        requestAnimationFrame(animate);
    }

    // Iniciar la simulación
    animate();
</script>
</body>
</html>
