<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Compresión y Expansión</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #000;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      color: #fff;
      font-family: Arial, sans-serif;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <script>
    // Configuración del canvas
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Configuración de archivos de audio
    const audioFiles = [
      'agitacion.mp3',
      'incertidumbre.mp3',
      'atencion.mp3',
      'presencia.mp3',
      'suspension.mp3',
      'desconexion.mp3'
    ];

    // Variables de audio
    let audioContext;
    let audios = [];
    let currentAudioIndex = -1;
    let isPlaying = false;
    let sequenceStarted = false;
    let lastInteractionTime = 0;
    let audioInitialized = false; // Nueva variable para verificar si el audio se ha inicializado

    // Variables de interacción
    let pointerX = canvas.width / 2;
    let pointerY = canvas.height / 2;
    let pointerSpeedX = 0;
    let pointerSpeedY = 0;
    let totalMovement = 0;

    // Simulación de tela
    const clothWidth = 400;
    const clothHeight = 300;
    const numPointsX = 30;
    const numPointsY = 20;
    const restDistance = clothWidth / numPointsX;

    class Point {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.pinned = false;
      }
    }

    class Cloth {
      constructor() {
        this.points = [];
        for (let y = 0; y <= numPointsY; y++) {
          for (let x = 0; x <= numPointsX; x++) {
            const px = canvas.width / 2 - clothWidth / 2 + clothWidth * (x / numPointsX);
            const py = canvas.height / 2 - clothHeight / 2 + clothHeight * (y / numPointsY);
            const point = new Point(px, py);
            point.pinned = y === 0;
            this.points.push(point);
          }
        }

        this.constraints = [];
        for (let y = 0; y <= numPointsY; y++) {
          for (let x = 0; x < numPointsX; x++) {
            this.constraints.push({ p1: this.getPoint(x, y), p2: this.getPoint(x + 1, y), distance: restDistance });
          }
        }
        for (let x = 0; x <= numPointsX; x++) {
          for (let y = 0; y < numPointsY; y++) {
            this.constraints.push({ p1: this.getPoint(x, y), p2: this.getPoint(x, y + 1), distance: restDistance });
          }
        }

        this.getPoint = (x, y) => this.points[y * (numPointsX + 1) + x];
      }

      update(dt) {
        const GRAVITY = 0.0981 * dt;
        const DAMPING = 0.97;

        for (let i = 0; i < this.points.length; i++) {
          const point = this.points[i];
          if (!point.pinned) {
            point.vy += GRAVITY;

            const prevX = point.x;
            const prevY = point.y;

            point.x += point.vx;
            point.y += point.vy;

            point.vx = (point.x - prevX) * DAMPING;
            point.vy = (point.y - prevY) * DAMPING;
          }
        }

        const iterations = 15;
        for (let i = 0; i < iterations; i++) {
          for (let j = 0; j < this.constraints.length; j++) {
            const constraint = this.constraints[j];
            const p1 = constraint.p1;
            const p2 = constraint.p2;

            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const diff = (constraint.distance - distance) / distance;

            const percent = p1.pinned ? 0 : 0.5;

            p1.x -= dx * diff * percent;
            p1.y -= dy * diff * percent;
            p2.x += dx * diff * (1 - percent);
            p2.y += dy * diff * (1 - percent);
          }
        }
      }

      draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.strokeStyle = "rgba(255, 255, 255, 0.7)";
        ctx.lineWidth = 2;

        for (let y = 0; y < numPointsY; y++) {
          for (let x = 0; x < numPointsX; x++) {
            const p1 = this.getPoint(x, y);
            const p2 = this.getPoint(x + 1, y);
            const p3 = this.getPoint(x + 1, y + 1);
            const p4 = this.getPoint(x, y + 1);

            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.lineTo(p3.x, p3.y);
            ctx.lineTo(p4.x, p4.y);
            ctx.closePath();
            ctx.stroke();
          }
        }
      }
    }

    const cloth = new Cloth();

    // Función para inicializar el contexto de audio
    function initAudioContext() {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      audios = audioFiles.map(file => {
        const audio = new Audio(file);
        audio.volume = 0.7;
        return audio;
      });
      audioInitialized = true; // Marcar que el audio se ha inicializado
    }

    // Función para reproducir el siguiente audio en la secuencia
    function playNextAudio() {
      if (!audioInitialized) {
        initAudioContext();
      }

      if (isPlaying) return;

      if (!sequenceStarted) {
        currentAudioIndex = Math.random() < 0.5 ? 0 : 4;
        sequenceStarted = true;
      } else {
        currentAudioIndex = (currentAudioIndex + 1) % audioFiles.length;
      }

      audios.forEach(audio => {
        audio.pause();
        audio.currentTime = 0;
      });

      const audio = audios[currentAudioIndex];
      audio.play();
      isPlaying = true;

      audio.onended = () => {
        isPlaying = false;
      };
    }

    function handlePointerMove(x, y) {
      pointerSpeedX = x - pointerX;
      pointerSpeedY = y - pointerY;

      pointerX = x;
      pointerY = y;

      if (!audioInitialized) {
        initAudioContext();
        playNextAudio();
      }

      const pointerForceRadius = 150;
      const pointerForce = 0.5;

      for (let i = 0; i < cloth.points.length; i++) {
        const point = cloth.points[i];
        const dx = point.x - pointerX;
        const dy = point.y - pointerY;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < pointerForceRadius) {
          const force = (1 - dist / pointerForceRadius) * pointerForce;
          point.vx += (pointerSpeedX * force) / 10;
          point.vy += (pointerSpeedY * force) / 10;
        }
      }
    }

    // Eventos de interacción
    canvas.addEventListener('mousemove', function(event) {
      handlePointerMove(event.clientX, event.clientY);
    });

    canvas.addEventListener('touchmove', function(event) {
      event.preventDefault();
      const touch = event.touches[0];
      handlePointerMove(touch.clientX, touch.clientY);
    });

    // Animación
    function animate() {
      const deltaTime = 16 / 1000;
      cloth.update(deltaTime);
      cloth.draw();
      requestAnimationFrame(animate);
    }

    animate();
  </script>
</body>
</html>



